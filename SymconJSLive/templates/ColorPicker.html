<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.86, maximum-scale=5.0, minimum-scale=0.86, user-scalable=no">
    <title>ColorPicker</title>
</head>
<script src="{ADDRESS}/hook/JSLive/js/jquery.min.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/iro/5.5.0/iro.js"></script>


<body style="text-align: center;">
<div id="picker"></div>

<script>
    let config_global = {GLOBAL};
    let config_variabels = {VARIABELS};
    let config_layout = {LAYOUT};
    let confiuration = {CONFIG};

    let colors_ids = [];
    let colorsTemperatures_ids = [];
    let colorsTemperaturesMode_ids = [];

    let colorPicker = new iro.ColorPicker("#picker",  LoadPicker());

    let last_update = Date.now();
    let updateId = [];
    let updateVal = [];
    let running = false;

    function LoadPicker(){
        var laydata = GenerateLayoutData();
        var wdh = window.innerHeight-20;

        if(wdh > window.innerWidth){
            wdh = window.innerWidth-20;
        }

        if(confiuration.layout_Direction === "vertical"){
            wdh = wdh - laydata.width_s;

            if(laydata.counter_wheelbox > 0){
                wdh = (wdh / laydata.counter_wheelbox) - 10;
            }
        }

        config = {
            layoutDirection: confiuration.layout_Direction,
            layout: laydata.output,
            colors: GenerateColorData(),
            width: wdh,
            borderColor: confiuration.style_borderColor,
            borderWidth: confiuration.style_borderWidth,
            handleRadius: confiuration.style_handleRadius

        };

        return config;
    }

    function GenerateLayoutData(){
        var output = [];
        var width_s = 0;
        var counter_wheelbox = 0;

        config_layout.forEach(function (part, index){
            item = {};
            options = {};

            switch(part.Layout){
                default:
                case "Wheel":
                    item["component"] = iro.ui.Wheel;
                    options["wheelLightness"] = confiuration.wheel_Lightness;
                    options["wheelAngle"] = confiuration.wheel_Angle;
                    options["wheelDirection"] = confiuration.wheel_Direction;
                    counter_wheelbox++;
                    break;
                case "Box":
                    item["component"] = iro.ui.Box;
                    counter_wheelbox++;
                    break;
                case "Slider":
                    item["component"] = iro.ui.Slider;
                    width_s = width_s + part.sliderSize + 10;
                    options["sliderType"] = part.sliderType;
                    options["sliderSize"] = part.sliderSize;
                    options["sliderShape"] = part.sliderShape;
                    break;
            }
            item["component"]

            item["options"] = options;
            output.push(item);
        });

        if(output.length === 0){
            //add default!
            //Wheel
            item = {};
            options = {};

            item["component"] = iro.ui.Wheel;
            output.push(item);
            counter_wheelbox++;

            //silder Value
            item = {};
            options = {};

            item["component"] = iro.ui.Slider;
            options["sliderType"] = "value";
            options["sliderSize"] = 40;
            item["options"] = options;
            output.push(item);
            width_s = width_s + 40 + 10;
        }

        return {"output": output, "width_s": width_s, "counter_wheelbox": counter_wheelbox};
    }
    function GenerateColorData(){
        var output = [];

        colors_ids = [];
        colorsTemperatures_ids = [];
        colorsTemperaturesMode_ids = [];

        config_variabels.forEach(function (part, index){
            if(part.Color.Variable === 0 || part.Temperature.Variable === 0){
                console.log("Überspinge Farbe => keine avriable gesetzt!");
            }else{
                if(part.Mode.Variable > 0 && part.Mode.Value){
                    //temperture Mode
                    temp = part.Temperature.Value;

                    if(part.Temperature.isMired){
                        temp = MiredToKelvin(temp);
                    }
                    output.push(colorTemperatureToRGB(temp));
                }else{
                    //color Mode
                    output.push(hexToRgb(part.Color.Value));
                }

                colors_ids.push(part.Color.Variable);
                colorsTemperatures_ids.push(part.Temperature.Variable);
                colorsTemperaturesMode_ids.push(part.Mode.Variable);

            }
        });

        return output;
    }

    colorPicker.on('color:change', function(color) {

        console.log(Date.now() + " >> ChangeColor (" + color.index + ") => " + color.rgb);

        id = config_variabels[color.index].Color.Variable;
        val = hexToInt(color.rgb);

        val2 = color.kelvin;
        if(config_variabels[color.index].Temperature.isMired){
            val2 = KelvinToMired(val2);
        }

        config_variabels[color.index].Color.Value = val;
        config_variabels[color.index].Temperature.Value = val;

        if(config_variabels[color.index].Mode.Value){
            id = config_variabels[color.index].Temperature.Variable;
            val = val2;

        }

        if(updateId.includes(id)){
            //updaten
            index = updateId.indexOf(id);
            updateVal[index] = val;
        }else{
            //anlegen
            updateId.push(id);
            updateVal.push(val);
        }

        console.log(Date.now() + " >> ChangeColor => "+ JSON.stringify(updateVal));

        if(!running) UpdateWorker();
    });

    async function UpdateWorker(){
        running = true;
        while (running){
            await sleep(1);
            try {
                //console.log("UpdateWorker => "+ updateVal.length + " | " + updateId.length);
                if((last_update + confiuration.DataUpdateRate) <= Date.now() && updateVal.length > 0 && updateId.length > 0){
                    last_update = Date.now();
                    //console.log("UpdateWorker => "+ JSON.stringify(updateVal) + " | " + JSON.stringify(updateId));

                    for (i = 0; i < updateVal.length; i++) {
                        console.log(Date.now() + " >> UpdateWorker | Update " + JSON.stringify(updateVal) + " | " + JSON.stringify(updateId));
                        console.log(Date.now() + " >> UpdateWorker | URL: {ADDRESS}/hook/JSLive/setData?Instance={INSTANCE}&pw={PASSWORD}&var=" +updateId[i]+ "&val="+updateVal[i]);
                        var response = await fetch("{ADDRESS}/hook/JSLive/setData?Instance={INSTANCE}&pw={PASSWORD}&var=" +updateId[i]+ "&val="+updateVal[i]);
                        console.log(Date.now() + " >> UpdateWorker Response => " + response.statusText + " (" + response.status + ")");
                    }

                    updateVal = [];
                    updateId = [];

                    console.log(Date.now() + " >> UpdateWorker => CLOSE");
                    running = false;
                }
            }catch (e) {
                console.log(Date.now() + " >> UpdateWorker => ", e);
            }
        }
    }

    function connect() {
        var ws = new WebSocket('{WSADDRESS}', [encodeURIComponent(btoa('webfront:{WEBFRONTPASSWORD}'))]);
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10603) {
                UpdateColorPicker(data.SenderID, data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log(Date.now() + ' >> Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error(Date.now() + ' >> Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateColorPicker(id_val, val){
        isUpdated = false;
        now = Date.now();
        if(running ) return;

        if(colors_ids.includes(id_val)){
            //änderung farbe
            index = colors_ids.indexOf(id_val);

            if(config_variabels[index].Color.Value !== val){
                console.log(Date.now() + " >> UpdateColorPicker (Color)" + index + " => " + val+ " (" + config_variabels[index].Color.Value + ")");
                config_variabels[index].Color.Value = val;
                isUpdated = true;
            }
        }

        if(colorsTemperatures_ids.includes(id_val)){
            //änderung temperture!!
            index = colorsTemperatures_ids.indexOf(id_val);

            if(config_variabels[index].Temperature.Value !== val){
                config_variabels[index].Temperature.Value = val;
                console.log(Date.now() + " >> UpdateColorPicker (Temp)" + index + " => " + val+ " (" + config_variabels[index].Temperature.Value + ")");
                isUpdated = true;
            }
        }

        if(colorsTemperaturesMode_ids.includes(id_val)){
            //änderung des Moduses
            index =  colorsTemperaturesMode_ids.indexOf(id_val);

            if(config_variabels[index].Mode.Value !== val){
                config_variabels[index].Mode.Value = val;
                console.log(Date.now() + " >> UpdateColorPicker (Mode)" + index + " => " + val + " (" + config_variabels[index].Mode.Value + ")");
            }
        }

        if(isUpdated){
            colorPicker.setColors(GenerateColorData());
        }
    }

    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    data.forEach(function (part, index) {
                        UpdateColorPicker(part.Color.Variable, part.Color.Value);
                        UpdateColorPicker(part.Temperature.Variable, part.Temperature.Value);
                        UpdateColorPicker(part.Mode.Variable, part.Mode.Value);
                    });
                });

                //Control Variables
            }catch (e) {
                console.log(Date.now() + " >> PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }

    function filterKeys(obj, func) {
        return Array.prototype.filter.call(Object.keys(obj), func, obj);
    }
    function someKeys(obj, func) {
        return Array.prototype.some.call(Object.keys(obj), func, obj);
    }
    function atLeastOnePropertyMatches(obj, requiredProp) {
        return someKeys(obj, function (prop) {
            if (requiredProp.hasOwnProperty(prop)) {
                return this[prop] === requiredProp[prop];
            }
        });
    }
    function getMatchingKeys(obj, requiredProp) {
        return filterKeys(obj, function (prop) {
            return atLeastOnePropertyMatches(this[prop], required);
        });
    }
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    function colorTemperatureToRGB(kelvin){
        var temp = kelvin / 100;
        var red, green, blue;

        if( temp <= 66 ){
            red = 255;
            green = temp;
            green = 99.4708025861 * Math.log(green) - 161.1195681661;

            if( temp <= 19){
                blue = 0;
            } else {
                blue = temp-10;
                blue = 138.5177312231 * Math.log(blue) - 305.0447927307;
            }
        } else {
            red = temp - 60;
            red = 329.698727446 * Math.pow(red, -0.1332047592);

            green = temp - 60;
            green = 288.1221695283 * Math.pow(green, -0.0755148492 );

            blue = 255;
        }

        return {
            r : clamp(red,   0, 255),
            g : clamp(green, 0, 255),
            b : clamp(blue,  0, 255)
        }
    }
    function clamp( x, min, max ) {
        if(x<min){ return min; }
        if(x>max){ return max; }

        return x;
    }
    function hexToRgb(bigint) {
        var r = (bigint >> 16) & 255;
        var g = (bigint >> 8) & 255;
        var b = bigint & 255;

        return {"r": r, "g": g, "b": b};
    }
    function hexToInt(rgb){
        var erg = rgb.r*256*256 + rgb.g*256 + rgb.b;
        console.log(Date.now() + " >> hexToInt => " + JSON.stringify(rgb) + " | " + erg);
        return erg;
    }

    function KelvinToMired(value){
        return Math.floor(1000000 / value);
    }
    function MiredToKelvin(value){
        return Math.floor(1000000 / value);
    }


    window.onload = function() {
        LoadPicker();

        if(config_global.LocalAddress == "{ADDRESS}" && config_global.LocalDataMode == 0){
            //pullup Mode local
            refreshRate = config_global.LocalRefreshTime;
            PullNewData(refreshRate);
        }else if(config_global.RemoteAddress == "{ADDRESS}" && config_global.RemoteDataMode == 0){
            //pullup Mode remote
            refreshRate = config_global.RemoteRefreshTime;
            PullNewData(refreshRate);
        }else{
            connect();
        }
    }
</script>
</body>
</html>