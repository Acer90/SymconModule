<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi">
    <title>{TITLE_TEXT}</title>
</head>
<script src="{ADDRESS}/hook/JSLive/js/jquery.min.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/canvas-gauges/gauge.min.js"></script>

<body style="text-align: center;">
<canvas id="gauge"></canvas>

<script>
    let gauge;

    let curValue = {VALUE};
    let config_global = {GLOBAL};
    let config_ticks = {TICKS};
    let config_highlights = {HIGHLIGHTS};
    let confiuration = {CONFIG};

    function LoadGauge(){
        if(!confiuration.title_display) confiuration.title_text = false;
        if(!confiuration.plate_unit) confiuration.plate_unit = false;
        if(!confiuration.progressbar_display) confiuration.progressbar_barWidth = 0;

        gauge_config = {
            renderTo: 'gauge',
            height: window.innerHeight-20,
            minValue: 0,
            maxValue: 360,
            majorTicks: [
                "N",
                "NE",
                "E",
                "SE",
                "S",
                "SW",
                "W",
                "NW",
                "N"
            ],
            minorTicks: 22,
            ticksAngle: 360,
            startAngle: 180,
            strokeTicks: false,
            highlights: false,

            title: confiuration.title_text, //false deaktiviert!
            colorTitle: confiuration.title_fontColor,
            fontTitleSize: confiuration.title_fontSize,
            units: confiuration.plate_unit,

            colorPlate: confiuration.plate_colorPlate,
            colorPlateEnd: confiuration.plate_colorPlateEnd,

            colorMajorTicks: confiuration.ticks_colorMajorTick,
            colorMinorTicks: confiuration.ticks_colorMinorTicks,
            colorUnits: confiuration.ticks_colorUnits,
            colorNumbers: confiuration.ticks_colorNumbers,

            colorNeedle: confiuration.needle_colorNeedle,
            colorNeedleEnd: confiuration.needle_colorNeedleEnd,
            valueBox: false,
            valueTextShadow: false,
            colorCircleInner: "#fff",
            colorNeedleCircleOuter: "#ccc",
            needleCircleSize: 15,
            needleCircleOuter: false,

            animationRule: "linear",
            needleType: "line",
            needleStart: 75,
            needleEnd: 99,
            needleWidth: 3,

            borders: true,
            borderInnerWidth: 0,
            borderMiddleWidth: 0,
            borderOuterWidth: 10,
            colorBorderOuter: "#ccc",
            colorBorderOuterEnd: "#ccc",
            colorNeedleShadowDown: "#222",
            borderShadowWidth: 0,
            animationTarget: "plate",
            animationDuration: 1500
        }

        gauge = new RadialGauge(gauge_config);
        gauge.draw();
        gauge.value = curValue;
    }

    function connect() {
        var ws = new WebSocket('{WSADDRESS}', [encodeURIComponent(btoa('webfront:{WEBFRONTPASSWORD}'))]);
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10603) {
                UpdateGauge(data.SenderID, data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error('Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateGauge(id_val, val){
        isUpdated = false;

        if(id_val == confiuration.variable){
            //console.log(val);
            gauge.value = val;
        }
    }

    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    data.forEach(function (part, index) {
                        UpdateGauge(part.Variable, part.Value);
                    });
                });

                //Control Variables
            }catch (e) {
                console.log("PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }

    function filterKeys(obj, func) {
        return Array.prototype.filter.call(Object.keys(obj), func, obj);
    }
    function someKeys(obj, func) {
        return Array.prototype.some.call(Object.keys(obj), func, obj);
    }
    function atLeastOnePropertyMatches(obj, requiredProp) {
        return someKeys(obj, function (prop) {
            if (requiredProp.hasOwnProperty(prop)) {
                return this[prop] === requiredProp[prop];
            }
        });
    }
    function getMatchingKeys(obj, requiredProp) {
        return filterKeys(obj, function (prop) {
            return atLeastOnePropertyMatches(this[prop], required);
        });
    }
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    window.onload = function() {
        LoadGauge();

        if(config_global.LocalAddress == "{ADDRESS}" && config_global.LocalDataMode == 0){
            //pullup Mode local
            refreshRate = config_global.LocalRefreshTime;
            PullNewData(refreshRate);
        }else if(config_global.RemoteAddress == "{ADDRESS}" && config_global.RemoteDataMode == 0){
            //pullup Mode remote
            refreshRate = config_global.RemoteRefreshTime;
            PullNewData(refreshRate);
        }else{
            connect();
        }
    }
</script>
</body>
</html>