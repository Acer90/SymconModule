<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{TITLE_TEXT}</title>
</head>
<script src="{ADDRESS}/hook/JSLive/js/jquery.min.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/chartjs/2.8.0/Chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@0.1.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@latest/dist/chartjs-plugin-streaming.min.js"></script>

<body>
<div id="data"></div>

<canvas id="myChart"></canvas>

<script>
    let myChart;

    let config_global = {GLOBAL};

    let config_dataset = {DATASETS};
    let config_axes = {AXES};
    let config_legend = {LEGEND};
    let config_tooltips = {TOOLTIPS};
    let config_title = {TITLE};
    let config_xaxes = {XAXES};

    let confiuration = {CONFIG};

    let update_vars = [];
    update_vars.push(confiuration.ID_Period);
    update_vars.push(confiuration.ID_Now);
    update_vars.push(confiuration.ID_StartDate);
    update_vars.push(confiuration.ID_Relativ);

    let last_update = Date.now();
    let offset_isSet = false;
    let last_reload = 0; //Damit der Chart nur einmal neugeladen wird!

    function updateChartconfig(){
        //modify dataset
        config_dataset.forEach(function(part, index) {
            if(config_dataset[index]["type"] == 'line'){
                //config_dataset[index]["lineTension"] = 0;
            }
        });

        let config = {
            type: 'bar',
            data: {
                datasets: config_dataset
            },
            options: {
                animation: {
                    duration: 500,                   // general animation time
                    easing: 'linear',
                },
                hover: {
                    animationDuration: 0           // duration of animations when hovering an item
                },
                responsiveAnimationDuration: 500,    // animation duration after a resize
                plugins: {
                    streaming: checkIsStreaming()
                },
                title: config_title,
                legend: config_legend,
                tooltips: config_tooltips,
                scales: {
                    xAxes: config_xaxes,
                    yAxes: config_axes
                },
                layout: {
                    padding: {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }
                }
            }
        };

        //add function tooltip
        t_callpack = {
                label: UpdateTooltipLabel
            };
        config.options.tooltips.callbacks = t_callpack;

        return config;
    }

    function connect() {
        var ws = new WebSocket('{WSADDRESS}', [encodeURIComponent(btoa('webfront:{WEBFRONTPASSWORD}'))]);
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
                //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            UpdateChart(data);
            ReloadChart(data);
        };

        ws.onclose = function(e) {
            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error('Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateChart(data){
        //wenn nicht Now dann kein Update durchführen!
        if(!confiuration.Now) return;

        //nur update bei Variablen änderung!
        if(data.Message != 10603) return;

        //console.log('Message:', e.data);

        isUpdated = false;

        required = {variable: data.SenderID};
        results = [];
        results = getMatchingKeys(config_dataset, required);

        //console.log('Result:', results);
        //nur Updaten wenn ID in Chart exestiert
        if(results.length > 0){
            period = confiuration["Period"];
            //updaten des Aktuellen Charts
            results.forEach(function(part, index) {
                //nur daten ohne Offset hier updaten
                offset = myChart.data.datasets[part].offset;
                if(offset == 0) {
                    val = data.Data[0];
                    highRes = myChart.data.datasets[part].highRes;
                    itemDate = UpdateDate(data.Data[3] * 1000, highRes);

                    if (highRes <= period) {
                        //highres Update
                        dataPoint = {
                            x: itemDate.getTime(),
                            y: val
                        }
                        myChart.data.datasets[part].data.push(dataPoint);

                    } else {
                        //check Timestamp vorhanden
                        required = {x: itemDate.getTime()};
                        results = [];
                        results = getMatchingKeys(myChart.data.datasets[part].data, required);
                        //console.log('Result:', results);

                        if (results.length > 0) {
                            //ja alten updaten
                            c = 1;
                            if (typeof myChart.data.datasets[part].data[results[0]].c != "undefined") {
                                oldval = myChart.data.datasets[part].data[results[0]].y;
                                c = myChart.data.datasets[part].data[results[0]].c;
                                val = Math.round(((oldval * c) + val) / (c + 1) * 100) / 100;
                                c++;
                            }

                            myChart.data.datasets[part].data[results[0]].y = val;
                            myChart.data.datasets[part].data[results[0]].c = c;
                        } else {
                            dataPoint = {
                                x: itemDate.getTime(),
                                y: val,
                                c: 1
                            }
                            myChart.data.datasets[part].data.push(dataPoint);
                        }

                    }
                }
            });

            myChart.update({
                preservation: true
            });
        }
    }
    function ReloadChart(data){
        //console.log("test: ", update_vars);
        if(data.Message != 10603) return;
        //deoppelten Reload verhinden!
        if(last_reload == data.Data[3]) return;
        if(!update_vars.includes(data.SenderID)) return;

        last_reload = data.Data[3];

        $.getJSON( "{ADDRESS}/hook/JSLive/getUpdate?Instance={INSTANCE}&pw={PASSWORD}", function( data ) {
            config_dataset = data.DATASETS;
            config_axes = data.AXES;
            config_xaxes =  data.XAXES;

            confiuration =  data.CONFIG;


            //neuerstellen (aufgrund des livestreming plugins!
            if(true){
            //if(data.SenderID == confiuration["ID_Relativ"] || data.SenderID == confiuration["ID_Period"]){
                console.log("RELOAD CHART Full!");
                myChart.destroy();
                var ctx = document.getElementById('myChart');
                myChart = new Chart(ctx, updateChartconfig());
            }else{
                //sonst nur updaten 8D
                console.log("RELOAD CHART!");
                myChart.update({
                    preservation: false
                });
            }
            last_update = Date.now();
            offset_isSet = checkOffsetisSet();
        });
    }
    async function UpdateConfiguration() {
        while (true){
            try {
                UpdateTimeScale();
                if(confiuration.Relativ && offset_isSet){
                    UpdateOffsetData_Relativ();
                }

                RemoveOldData()
            }catch (e) {
                console.log("UpdateOffsetData_Relativ => ", e);
            }
            await sleep(1000);
        }
    }

    function UpdateDate(date, highRes = 7){
        let period = confiuration["Period"];
        let oldDate = new Date(date);
        let newDate = new Date();

        if(highRes <= period){
            newDate = oldDate;
        }else{
            switch(period){
                case 0:
                    //dekade
                    newDate = new Date(oldDate.getFullYear(), 0, 1, 0, 0, 0);
                    break;
                case 1:
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), 1, 0, 0, 0);
                    //Jahr
                    break;
                case 2:
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), 1, 0, 0, 0);
                    //quartal
                    break;
                case 3:
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    //Monat
                    break;
                case 4:
                    //woche
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    break;
                case 5:
                    //tag
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), 0, 0);
                    break;
                case 6:
                    //stunde
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), 0);
                    break;
                case 7:
                    //minute
                    newDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                default:
                    newDate = oldDate;
                    break;
            }
        }

        //console.log("oldDate:", oldDate);
        //console.log("newDate:", newDate);
        return newDate;
    }
    function UpdateTimeScale(){
        //nur wenn live ausführen!
        if(!confiuration.Now) return;

        curDate = Date.now();
        old_endDate = myChart.options.scales.xAxes[0].time.max;

        if(curDate > old_endDate){
            dateData = GetStartEndDate(curDate);
            myChart.options.scales.xAxes[0].time.min = dateData.start;
            myChart.options.scales.xAxes[0].time.max = dateData.end;

            if(!confiuration.Relativ){
                //update offset Absolut
                UpdateOffsetData_Absolute(curDate);
            }
        }
    }

    function RemoveOldData() {
        if (myChart.options.scales.xAxes[0].type != "realtime") {
            itemDate = myChart.options.scales.xAxes[0].time.min;

            //löschdatum holen
            myChart.data.datasets.forEach(function (part, index) {
                rDate = GetRemoveDate(UpdateDate(itemDate, part.highRes));
                //console.log("part" ,part);
                // in jeder chart älteres Daten löschen
                myChart.data.datasets[index].data.forEach(function (spart, sindex) {
                    //beginend von vorn
                    if (spart.x <= rDate.getTime()) {
                        //löschen wenn älter
                        //console.log("lösche Index:", sindex);
                        myChart.data.datasets[index].data.splice(sindex, 1);
                    }
                });
            });
        }
    }
    function UpdateOffsetData_Relativ() {
        if (confiuration.Relativ) {
            curDate = Date.now();

            myChart.data.datasets.forEach(function (part, index) {
                offset = part.offset;
                c = part.data.length - 1;

                if (offset > 0 && c > 0) {

                    start = Math.floor((part.data[c].x) / 1000);
                    end = Math.floor((curDate) / 1000);

                    highRes = part.highRes;
                    $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}&var=" + part.variable + "&offset=" + offset + "&hires=" + highRes + "&start=" + start + "&end=" + end, function (data) {
                        //console.log("update Offset: ", data);

                        data.archiv.forEach(function (apart, aindex) {
                            myChart.data.datasets[index].data.push(apart);
                            isUpdated = true;
                        });
                    });
                }

            });

            myChart.update(0);
        }
    }
    async function UpdateOffsetData_Absolute(curDate) {
        //absolute Mode
        console.log("UpdateOffsetData_Absolute");
        dateData = GetStartEndDate(Date.now());
        start = Math.floor(dateData.start / 1000);
        end = Math.floor(dateData.end / 1000) + 1000;

        myChart.data.datasets.forEach(function (part, index) {
            offset = part.offset;
            c = part.data.length - 1;

            if (offset > 0 && c > 0) {

                highRes = part.highRes;
                $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}&var=" + part.variable + "&offset=" + offset + "&hires=" + highRes + "&start=" + start + "&end=" + end, function (data) {
                    //console.log("update Offset: ", data);

                    data.archiv.forEach(function (apart, aindex) {
                        myChart.data.datasets[index].data.push(apart);
                        isUpdated = true;
                    });
                });
            }

        });

        myChart.update(0);
    }

    function GetStartEndDate(date) {
        period = confiuration.Period;
        is_relativ = confiuration.Relativ;
        oldDate = new Date(date);

        eDate = new Date();
        sDate = new Date();

        if(is_relativ){
            eDate = oldDate;
            switch(period){
                case 0:
                    //dekade
                    sDate = new Date((oldDate.getFullYear()-10), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 1:
                    //Jahr
                    sDate = new Date((oldDate.getFullYear()-1), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 2:
                    //quartal
                    sDate = new Date(oldDate.getFullYear(), (oldDate.getMonth()-3), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 3:
                    //Monat
                    sDate = new Date(oldDate.getFullYear(), (oldDate.getMonth()-1), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 4:
                    //woche
                    //immer montag starten
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()-7), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 5:
                    //tag
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()-1), oldDate.getHours(), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 6:
                    //stunde
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), (oldDate.getHours()-1), oldDate.getMinutes(), oldDate.getSeconds());
                    break;
                case 7:
                    //minute
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), (oldDate.getMinutes()-1), oldDate.getSeconds());
                    break;
                default:
                    sDate = oldDate;
                    break;
            }
        }else{
            switch(period){
                case 0:
                    //dekade
                    startyear = parseInt(oldDate.getFullYear() / 10) * 10;
                    sDate = new Date(startyear, 0, 0, 0, 0, 0);
                    eDate = new Date((startyear+10), 0, 0, 0, 0, 0);
                    break;
                case 1:
                    //Jahr
                    sDate = new Date(oldDate.getFullYear(), 0, 0, 0, 0, 0);
                    eDate = new Date((oldDate.getFullYear()+1), 0, 0, 0, 0, 0);
                    break;
                case 2:
                    //quartal
                    starmonth = parseInt(oldDate.getMonth() / 3) * 3;
                    sDate = new Date(oldDate.getFullYear(), starmonth, 0, 0, 0, 0);
                    eDate = new Date(oldDate.getFullYear(), (starmonth+3), 0, 0, 0, 0);
                    break;
                case 3:
                    //Monat
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), 0, 0, 0, 0);
                    eDate = new Date(oldDate.getFullYear(), (oldDate.getMonth()+1), 0, 0, 0, 0);
                    break;
                case 4:
                    //woche
                    //immer montag starten
                    var day = oldDate.getDay(),
                        diff = d.getDate() - day + (day == 0 ? -6:1); // adjust when day is sunday
                    oldDate = oldDate.setDate(diff);
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    eDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()+7), 0, 0, 0);
                    break;
                case 5:
                    //tag
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    eDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()+1), 0, 0, 0);
                    break;
                case 6:
                    //stunde
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), 0, 0);
                    eDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), (oldDate.getHours()+1), 0, 0);
                    break;
                case 7:
                    //minute
                    sDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), 0);
                    eDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), (oldDate.getMinutes()+1), 0);
                    break;
                default:
                    eDate = oldDate;
                    sDate = oldDate;
                    break;
            }
        }
        //console.log("sDate:", sDate);
        //console.log("eDate:", eDate);


        return { "start": sDate, "end": eDate};
    }
    function GetRemoveDate(date){
        period = confiuration.Period;
        is_relativ = confiuration.Relativ;
        oldDate = new Date(date);
        rDate = new Date();

        //console.log("mode:", is_relativ);
        //console.log("oldDate:", oldDate);

        if(is_relativ){
            switch(period){
                case 0:
                    //dekade
                    rDate = new Date((oldDate.getFullYear()-10), 0, 1, 0, 0, 0);
                    break;
                case 1:
                    //Jahr
                    rDate = new Date((oldDate.getFullYear()-1), oldDate.getMonth(), 1, 0, 0, 0);
                    break;
                case 2:
                    //quartal
                    rDate = new Date(oldDate.getFullYear(), (oldDate.getMonth()-3), 1, 0, 0, 0);
                    break;
                case 3:
                    //Monat
                    rDate = new Date(oldDate.getFullYear(), (oldDate.getMonth()-1), oldDate.getDate(), 0, 0, 0);
                    break;
                case 4:
                    //woche
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()-7), 0, 0, 0);
                    break;
                case 5:
                    //tag
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), (oldDate.getDate()-1), oldDate.getHours(), 0, 0);
                    break;
                case 6:
                    //stunde
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), (oldDate.getHours()-1), oldDate.getMinutes(), 0);
                    break;
                case 7:
                    //minute
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), (oldDate.getMinutes()-1), oldDate.getSeconds());
                    break;
                default:
                    rDate = new Date(0);
                    break;
            }
        }else{
            switch(period){
                case 0:
                    //dekade
                    startyear = parseInt(oldDate.getFullYear() / 10) * 10;
                    rDate = new Date(startyear, 0, 0, 0, 0, 0);
                    break;
                case 1:
                    //Jahr
                    rDate = new Date(oldDate.getFullYear(), 0, 0, 0, 0, 0);
                    break;
                case 2:
                    //quartal
                    starmonth = parseInt(oldDate.getMonth() / 3) * 3;
                    rDate = new Date(oldDate.getFullYear(), starmonth, 0, 0, 0, 0);
                    break;
                case 3:
                    //Monat
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), 0, 0, 0, 0);
                    break;
                case 4:
                    //woche
                    //immer montag starten
                    var day = oldDate.getDay(),
                        diff = d.getDate() - day + (day == 0 ? -6:1); // adjust when day is sunday
                    oldDate = oldDate.setDate(diff);
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    break;
                case 5:
                    //tag
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), 0, 0, 0);
                    break;
                case 6:
                    //stunde
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), 0, 0);
                    break;
                case 7:
                    //minute
                    rDate = new Date(oldDate.getFullYear(), oldDate.getMonth(), oldDate.getDate(), oldDate.getHours(), oldDate.getMinutes(), 0);
                    break;
                default:
                    rDate = new Date(0);
                    break;
            }
        }

        //console.log("rDate:", rDate);
        return rDate;
    }
    function checkIsStreaming(){
        if(confiuration.Relativ == false) return false;
        switch(confiuration.Period){
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                return false;
            case 6:
            case 7:
                return {framerate: 30};
            default: return false;
        }

    }
    function checkOffsetisSet(){
        isSet = false
        myChart.data.datasets.forEach(function(part, index) {
            offset = part.offset;

            if(offset > 0) isSet = true;
        });

        return isSet;
    }
    function UpdateTooltipLabel(tooltipItem, data){
        let dataset = data.datasets[tooltipItem.datasetIndex];

        let Suffix = "";
        let Prefix = "";
        let blocks = [];


        required = {id: data.datasets[tooltipItem.datasetIndex].yAxisID};
        AxisData = [];
        Axiskeys = getMatchingKeys(config_axes, required);


        Axiskeys.forEach(function(part, index) {
            Suffix = config_axes[part].Suffix;
            Prefix = config_axes[part].Prefix;
        });

        if (dataset.label) {
            blocks.push(dataset.label + ': ');
        }
        if (Prefix !== "") {
            blocks.push(Prefix);
        }
        blocks.push(dataset.data[tooltipItem.index].y)
        if (Suffix !== "") {
            blocks.push(Suffix);
        }
        return blocks.join('');
    }

    function filterKeys(obj, func) {
        return Array.prototype.filter.call(Object.keys(obj), func, obj);
    }
    function someKeys(obj, func) {
        return Array.prototype.some.call(Object.keys(obj), func, obj);
    }
    function atLeastOnePropertyMatches(obj, requiredProp) {
        return someKeys(obj, function (prop) {
            if (requiredProp.hasOwnProperty(prop)) {
                return this[prop] === requiredProp[prop];
            }
        });
    }
    function getMatchingKeys(obj, requiredProp) {
        return filterKeys(obj, function (prop) {
            return atLeastOnePropertyMatches(this[prop], required);
        });
    }
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    window.onload = function() {
        var ctx = document.getElementById('myChart');
        myChart = new Chart(ctx, updateChartconfig());
        offset_isSet = checkOffsetisSet();
        connect();
        UpdateConfiguration();
    }
</script>
</body>
</html>