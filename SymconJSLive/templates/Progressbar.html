<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {VIEWPORT} <!-- Dont Remove this line, it can be disabled at intstance! -->
    <title>Progressbar</title>
    <link rel="stylesheet" href="{ADDRESS}/hook/JSLive/js/loading-Bar/loading-bar.css">
    {FONTS} <!-- Need for Custom font Family !-->
</head>

<script src="{ADDRESS}/hook/JSLive/js/jquery.min.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/loading-Bar/loading-bar.js"></script>
<style type="text/css">
    path { mask: url(#mask); }
</style>

<body style="text-align: center;">

<div class="myBar" id="Bar"></div>

<svg height="0" width="0">
    <mask id="mask">
        <path id="dash_path" d="" stroke-width="15" stroke="#fff" stroke-dasharray=""></path>
    </mask>
</svg>

<script>
    let config_global = {GLOBAL};
    let value = {VALUE};
    let confiuration = {CONFIG};

    last_update = Date.now();

    let Bar

    function Load(){
        try {
            item = document.getElementById("Bar");
            //görße automatisch anpassen
            item.style.width = (window.innerWidth-40)+"px";

            if(confiuration.style_fontPosition === "center"){
                item.style.height = (window.innerHeight-40)+"px";
            }else{
                item.style.height = (window.innerHeight-60-confiuration.style_fontSize)+"px";
            }
            console.log("Automatic Size: W: " + item.style.width+"px | H: " + item.style.height+ "px");

            //wenn text mittig angezeigt werden soll
            if(confiuration.style_fontPosition === "center"){
                item.className = item.className + " label-center";
            }

            //configuration dashpart
            d_item = document.getElementById("dash_path");
            if(confiuration.Type === "stroke" && confiuration.shape_path !== "" && confiuration.stroke_Dash1 > 0 && confiuration.stroke_Dash2 > 0){
                d_item.classList.add("path");

                //set dash configuration
                d_item.setAttribute("d", confiuration.shape_path);
                d_item.setAttribute("stroke-dasharray", confiuration.stroke_Dash1 + " " + confiuration.stroke_Dash2);
                d_item.setAttribute("stroke-width", confiuration.stroke_width);
            }else{
                //entfernen der Mask damit diese nicht geladen werden kann
                document.getElementById("mask").remove();
            }

            //suffix und Präfix
            //item.append('<style>.wrapper:after{content: "Test";  display: inline;}</style>');
            //$( '<style>.wrapper:after { content: "Test"; }</style>' ).appendTo( "head" )
            var styleElem = document.head.appendChild(document.createElement("style"));
            styleElem.innerHTML = ".ldBar-label:after {content: \""+confiuration.suffix+"\";}.ldBar-label:before {content: \""+confiuration.prefix+"\";}";


            bar = new ldBar(".myBar", LoadBarConfig());


            document.querySelectorAll('.ldBar-label').forEach(function(el) {
                //Wenn Schrifft ausgeblendet werden soll
                if(!confiuration.style_fontDisplay){
                    el.style.display = 'none';
                }
                el.style.fontSize = confiuration.style_fontSize+'px';
                el.style.color = confiuration.style_fontColor;
                el.style.content = "px";
                el.style.fontFamily = confiuration.style_fontFamily;
            });
        }catch (e) {
            alert(e);
        }
    }

    function LoadBarConfig(){
        output = {};

        if(confiuration.shape_svg !== ""){
            output["img"] = "{ADDRESS}/hook/JSLive/getSVG?Instance={INSTANCE}&pw={PASSWORD}";
            //output["img"] = "data:image/jpeg;base64," + confiuration.shape_svg;
            //output["img-size"] = "1500,500";
        }
        else if(confiuration.shape_path !== ""){
            output["path"] = confiuration.shape_path;
        }

        output["type"] =  confiuration.Type;
        if(confiuration.shape_svg === "" && confiuration.shape_path === "")  output["preset"] =  confiuration.shape_preset; //fan line bubble circle

        output["precision"] = confiuration.data_precision;
        if(confiuration.data_precisionCustom !== 0)  output["precision"] = confiuration.data_precisionCustom;

        output["value"] = value;
        output["min"] = confiuration.data_min;
        output["max"] = confiuration.data_max;

        output["duration"] = confiuration.data_animationDuration;
        output["transition-in"] = confiuration.data_animationTransitionIn;

        hexstr = RGBAToHexA(confiuration.stroke_color_rgb.R,confiuration.stroke_color_rgb.G,confiuration.stroke_color_rgb.B, confiuration.stroke_color_Alpha);
        output["stroke"] = hexstr;
        output["stroke-dir"] = confiuration.stroke_dir;
        output["stroke-lincap"] = confiuration.stroke_lincap;
        output["stroke-width"] = confiuration.stroke_width;
        output["stroke-trail"] = confiuration.stroke_trailColor;
        output["stroke-trail-width"] = confiuration.stroke_trailWidth;
        output["stroke-dasharray"] = "3 6";

        hexstr = RGBAToHexA(confiuration.fill_color_rgb.R,confiuration.fill_color_rgb.G,confiuration.fill_color_rgb.B, confiuration.fill_color_Alpha); //confiuration.fill_color;
        output["fill"] = hexstr;
        output["fill-dir"] = confiuration.fill_dir;
        output["fill-background-extrude"] = confiuration.fill_backgroundExtrude;
        output["fill-background"] = confiuration.fill_backgroundColor;

        //override
        if(confiuration.override_stroke !== "") output["stroke"] = confiuration.override_stroke;
        if(confiuration.override_fill !== "") output["fill"] = confiuration.override_fill;

        return output;
    }


    function connect() {
        var ws = new WebSocket('{WSADDRESS}', [encodeURIComponent(btoa('webfront:{WEBFRONTPASSWORD}'))]);
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10603) {
                Update(data.SenderID, data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log(Date.now() + ' >> Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error(Date.now() + ' >> Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }
    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    Update(data.Variable, data.Value);
                });

                //Control Variables
            }catch (e) {
                console.log(Date.now() + " >> PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }
    function Update(id_val, val){
        if(id_val === confiuration.Variable && value !== val){
            value = val;
            bar.set(value);
        }
    }


    function filterKeys(obj, func) {
        return Array.prototype.filter.call(Object.keys(obj), func, obj);
    }
    function someKeys(obj, func) {
        return Array.prototype.some.call(Object.keys(obj), func, obj);
    }
    function atLeastOnePropertyMatches(obj, requiredProp) {
        return someKeys(obj, function (prop) {
            if (requiredProp.hasOwnProperty(prop)) {
                return this[prop] === requiredProp[prop];
            }
        });
    }
    function getMatchingKeys(obj, requiredProp) {
        return filterKeys(obj, function (prop) {
            return atLeastOnePropertyMatches(this[prop], required);
        });
    }
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    function RGBAToHexA(r,g,b,a) {
        r = r.toString(16);
        g = g.toString(16);
        b = b.toString(16);
        a = Math.round(a * 255).toString(16);

        if (r.length == 1)
            r = "0" + r;
        if (g.length == 1)
            g = "0" + g;
        if (b.length == 1)
            b = "0" + b;
        if (a.length == 1)
            a = "0" + a;

        return "#" + r + g + b + a;
    }

    window.onload = function() {
        try {
            Load();

            if (config_global.LocalAddress == "{ADDRESS}" && config_global.LocalDataMode == 0) {
                //pullup Mode local
                refreshRate = config_global.LocalRefreshTime;
                PullNewData(refreshRate);
            } else if (config_global.RemoteAddress == "{ADDRESS}" && config_global.RemoteDataMode == 0) {
                //pullup Mode remote
                refreshRate = config_global.RemoteRefreshTime;
                PullNewData(refreshRate);
            } else {
                connect();
            }
        }catch (e) {
            alert(e);
        }
    }

</script>
</body>
</html>