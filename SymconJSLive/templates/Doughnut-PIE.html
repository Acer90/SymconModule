<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!--<meta name="viewport" content='width=device-width, initial-scale=0.86, maximum-scale=5.0, minimum-scale=0.86, user-scalable=no'>-->
    <title>{TITLE_TEXT}</title>
</head>
<script src="{ADDRESS}/hook/JSLive/js/jquery.min.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/chartjs/2.8.0/Chart.js"></script>
<script src="{ADDRESS}/hook/JSLive/js/chartjs/2.8.0/plugins/chartjs-plugin-datalabels.min.js"></script>

<body>
<div id="data"></div>

<canvas id="myChart"></canvas>

<script>
    let myChart;

    let config_global = {GLOBAL};

    let config_data = {DATA};
    let config_legend = {LEGEND};
    let config_tooltips = {TOOLTIPS};
    let config_title = {TITLE};

    let confiuration = {CONFIG};

    function updateChartconfig(){
        try {
            let config = {
                type: confiuration.type,
                data: config_data,
                options: {
                    animation: {
                        duration: 500,                   // general animation time
                        easing: 'linear',
                    },
                    hover: {
                        animationDuration: 0           // duration of animations when hovering an item
                    },
                    responsiveAnimationDuration: 500,    // animation duration after a resize
                    title: config_title,
                    legend: config_legend,
                    tooltips: config_tooltips,
                    layout: {
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    plugins: {
                        datalabels: {
                            display: confiuration.datalabels_enabled,
                            color: confiuration.datalabels_fontColor,
                            font: {
                                size: confiuration.datalabels_fontSize
                            },
                            clamp: confiuration.datalabels_clamp,
                            align: confiuration.datalabels_align,
                            anchor: confiuration.datalabels_anchoring,
                            formatter: function(value, context) {
                                str = config_data.prefix[context.dataIndex] + value + config_data.suffix[context.dataIndex];
                                if(value === "") str = "";
                                return str;
                            }
                        }
                    },
                    circumference: Math.PI * (confiuration.rotation_length / 180),
                    rotation: Math.PI * (confiuration.rotation_start / 180)
                }
            };

            //add function tooltip
            t_callpack = {
                label: UpdateTooltipLabel
            };
            config.options.tooltips.callbacks = t_callpack;

            return config;
        } catch (e) {
            alert(e);
        }
    }

    function connect() {
        var ws = new WebSocket('{WSADDRESS}', [encodeURIComponent(btoa('webfront:{WEBFRONTPASSWORD}'))]);
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10603) {
                UpdateChart(data.SenderID, data.Data[3], data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error('Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateChart(id_val, dt_val, value){
        isUpdated = false;

        myChart.data.datasets.forEach(function(part, index){
            var_arr = part.variables;

            if(var_arr.includes(id_val)){
                var_index = var_arr.indexOf(id_val)

                val = Math.round(value * 100) / 100;
                myChart.data.datasets[index].data[var_index] = val;

                isUpdated = true;
            }
        });

        if(isUpdated){
            myChart.update();
        }
    }

    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                //console.log("PullNewData => ", Date.now());
                dt_val = Math.floor(Date.now() / 1000);
                $.getJSON("{ADDRESS}/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    data.forEach(function (part, index) {
                        UpdateChart(part.Variable, dt_val, part.Value);
                    });
                });

                //Control Variables
            }catch (e) {
                console.log("PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }

    function UpdateTooltipLabel(tooltipItem, data){
        let dataset = data.datasets[tooltipItem.datasetIndex];

        let Suffix = "";
        let Prefix = "";
        let blocks = [];

        Suffix = data.suffix[tooltipItem.datasetIndex];
        Prefix = data.prefix[tooltipItem.datasetIndex];

        if (dataset.label) {
            blocks.push(dataset.label + ': ');
        }
        if (Prefix !== "") {
            blocks.push(Prefix);
        }
        blocks.push(dataset.data[tooltipItem.index])
        if (Suffix !== "") {
            blocks.push(Suffix);
        }
        return blocks.join('');
    }

    function filterKeys(obj, func) {
        return Array.prototype.filter.call(Object.keys(obj), func, obj);
    }
    function someKeys(obj, func) {
        return Array.prototype.some.call(Object.keys(obj), func, obj);
    }
    function atLeastOnePropertyMatches(obj, requiredProp) {
        return someKeys(obj, function (prop) {
            if (requiredProp.hasOwnProperty(prop)) {
                return this[prop] === requiredProp[prop];
            }
        });
    }
    function getMatchingKeys(obj, requiredProp) {
        return filterKeys(obj, function (prop) {
            return atLeastOnePropertyMatches(this[prop], required);
        });
    }
    Array.prototype.insert = function ( index, item ) {
        this.splice( index, 0, item );
    };
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    window.onload = function() {
        try {
            var ctx = document.getElementById('myChart');
            myChart = new Chart(ctx, updateChartconfig());

            if (config_global.LocalAddress == "{ADDRESS}" && config_global.LocalDataMode == 0) {
                //pullup Mode local
                refreshRate = config_global.LocalRefreshTime;
                PullNewData(refreshRate);
            } else if (config_global.RemoteAddress == "{ADDRESS}" && config_global.RemoteDataMode == 0) {
                //pullup Mode remote
                refreshRate = config_global.RemoteRefreshTime;
                PullNewData(refreshRate);
            } else {
                connect();
            }
        }catch (e) {
            alert("Doughnut-Pie | ", e);
        }
    }
</script>
</body>
</html>