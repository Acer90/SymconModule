<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {VIEWPORT} <!-- Dont Remove this line, it can be disabled at intstance! -->
    <title>{TITLE_TEXT}</title>
    {FONTS} <!-- Need for Custom font Family !-->
</head>
<script src="/hook/JSLive/js/jquery.min.js"></script>
<script src="/hook/JSLive/js/util.js"></script>
<script src="/hook/JSLive/js/chartjs/3.2.1/chart.min.js" charset="utf-8"></script>
<script src="/hook/JSLive/js/moment/2.27.0/Moment.js" charset="utf-8"></script>
<script src="/hook/JSLive/js/chartjs/3.2.1/plugins/chartjs-adapter-moment.js" charset="utf-8"></script>
<script src="/hook/JSLive/js/chartjs/3.2.1/plugins/chartjs-plugin-datalabels.min.js" charset="utf-8"></script>

<body>
<div id="data"></div>

<canvas id="myChart"></canvas>

<script>
    let myChart;

    let config_global = {GLOBAL};

    let config_data = [];//{/DATA};
    let config_legend = {LEGEND};
    let config_tooltips = {TOOLTIPS};
    let config_title = {TITLE};

    let confiuration = {CONFIG};

    let last_reload = 0; //Damit der Chart nur einmal neugeladen wird!
    let isReloading = true;

    function updateChartconfig(){
        try {
            //Eneable Datalabels
            Chart.register(ChartDataLabels);

            var config = {
                type: confiuration.type,
                data: config_data,
                options: {
                    animation: {
                        duration: confiuration.animation_duration,
                        easing: confiuration.animation_easing,
                    },
                    hover: {
                        animationDuration: 0           // duration of animations when hovering an item
                    },
                    responsiveAnimationDuration: 0,    // animation duration after a resize
                    layout: {
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    responsive: true,
                    aspectRatio: 2.1,
                    plugins: {
                        title: config_title,
                        legend: config_legend,
                        tooltip: config_tooltips,
                        datalabels: {
                            display: false,
                            align: confiuration.datalabels_align,
                            anchor: confiuration.datalabels_anchoring,

                            borderRadius: confiuration.datalabels_borderRadius,
                            borderWidth: confiuration.datalabels_borderWidth,
                            font: {
                                size: confiuration.datalabels_fontSize,
                                family: confiuration.datalabels_fontFamily
                            },
                            color: confiuration.datalabels_fontColor,
                            //clip: true,
                            clamp: true,
                            formatter: function(value, context) {
                                var str = value;
                                if(str === 0 || str === null || str === "") return "";

                                if(context.dataset.datalabels.showPrefix){
                                    str = config_data.prefix[context.dataIndex] + str;
                                }
                                if(context.dataset.datalabels.showSuffix){
                                    str = str + config_data.suffix[context.dataIndex];
                                }

                                return  str;
                            },
                            backgroundColor: function(context) {
                                var str = context.dataset.data[context.dataIndex];
                                if(str === 0 || str === null || str === "") return "rgba(0,0,0,0)";

                                if(context.dataset.datalabels.useBackgroundColor){
                                    return context.dataset.backgroundColor;
                                }else{
                                    return context.dataset.datalabels.BackgroundColor;
                                }
                            },
                            borderColor: function(context) {
                                var str = context.dataset.data[context.dataIndex];
                                if(str === 0 || str === null || str === "") return "rgba(0,0,0,0)";

                                if(context.dataset.datalabels.useBorderColor){
                                    return context.dataset.borderColor;
                                }else{
                                    return context.dataset.datalabels.BorderColor;
                                }
                            }
                        }
                    },
                    circumference: confiuration.rotation_length,
                    rotation: confiuration.rotation_start
                }
            };

            //add function tooltip
            t_callpack = {
                label: UpdateTooltipLabel
            };
            config.options.plugins.tooltip.callbacks = t_callpack;

            return config;
        } catch (e) {
            alert(e);
        }
    }

    function connect() {
        var ws = new WebSocket(location['protocol'].replace(/^http/, 'ws') + "//" + location['host'] + "/hook/JSLive/WS/" + {INSTANCE});
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10506) {
                //refresh webseite
                location.reload();
            } else if(data.Message == 10603) {
                UpdateChart(data.SenderID, data.Data[3], data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error('Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateChart(id_val, dt_val, value){
        isUpdated = false;

        myChart.data.datasets.forEach(function(part, index){
            var_arr = part.variables;

            if(var_arr.includes(id_val)){
                var_index = var_arr.indexOf(id_val)
                precision = Math.pow(10, confiuration.data_precision);

                val = Math.floor(value * precision) /  precision;
                myChart.data.datasets[index].data[var_index] = val;

                isUpdated = true;
            }
        });

        if(isUpdated){
            myChart.update();
        }
    }

    function ReloadChart(dt_val){
        //deoppelten Reload verhinden!
        if(last_reload === dt_val) return;
        last_reload = dt_val;
        isReloading = true;


        //sync load of all Data
        $.getJSON( "/hook/JSLive/getUpdate?Instance={INSTANCE}&pw={PASSWORD}", function( data ) {
            config_data = data.DATASETS;
            confiuration = data.CONFIG;

            console.log("RELOAD CHART Full!");
            if(typeof myChart !== "undefined") myChart.destroy();
            var ctx = document.getElementById('myChart');
            myChart = new Chart(ctx, updateChartconfig());
            last_update = Date.now();
            isReloading = false;
        });
    }

    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                //console.log("PullNewData => ", Date.now());
                dt_val = Math.floor(Date.now() / 1000);
                $.getJSON("/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    data.forEach(function (part, index) {
                        UpdateChart(part.Variable, dt_val, part.Value);
                    });
                });

                //Control Variables
            }catch (e) {
                console.log("PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }

    function UpdateTooltipLabel(tooltipItem){
        var dataset = tooltipItem.dataset

        var Suffix = "";
        var Prefix = "";
        var blocks = [];
        var val = dataset.data[tooltipItem.dataIndex];

        if(val === null || val === 0 || val === "") return "";

        Suffix = config_data.suffix[tooltipItem.datasetIndex];
        Prefix = config_data.prefix[tooltipItem.datasetIndex];

        if (dataset.label) {
            blocks.push(dataset.label + ': ');
        }
        if (Prefix !== "") {
            blocks.push(Prefix);
        }
        blocks.push(val)
        if (Suffix !== "") {
            blocks.push(Suffix);
        }
        return blocks.join('');
    }

    function bootUp(){
        try {
            //load config after Startup
            var dt_val = Math.floor(Date.now() / 1000);
            ReloadChart(dt_val);

            if (config_global.DataMode === 0) {
                //pullup Mode
                var refreshRate = config_global.RefreshTime;
                PullNewData(refreshRate);
            } else {
                connect();
            }
        }catch (e) {
            alert("Doughnut-Pie | ", e.message);
        }
    }

    window.onload = function() {
        bootUp();
    }
</script>
</body>
</html>