<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    {VIEWPORT} <!-- Dont Remove this line, it can be disabled at intstance! -->
    <title>{TITLE_TEXT}</title>
</head>
{FONTS} <!-- Need for Custom font Family !-->

<script src="/hook/JSLive/js/jquery.min.js"></script>
<script src="/hook/JSLive/js/util.js"></script>
<script src="/hook/JSLive/js/canvas-gauges/gauge.min.js"></script>

<body>
<canvas id="gauge"></canvas>

<script>
    let gauge;

    let curValue = {VALUE};
    let config_global = {GLOBAL};
    let config_ticks = {TICKS};
    let config_highlights = {HIGHLIGHTS};
    let confiuration = {CONFIG};

    function LoadGauge(){
        try {
            if (!confiuration.title_display) confiuration.title_text = false;
            if (!confiuration.plate_unit) confiuration.plate_unit = false;
            if (!confiuration.progressbar_display) confiuration.progressbar_barWidth = 0;

            gauge_config = {
                renderTo: 'gauge',

                width: window.innerWidth - 20,
                height: window.innerHeight - 20,

                units: confiuration.plate_unit,

                value: {VALUE},
                minValue: confiuration.min,
                maxValue: confiuration.max,

                //title
                title: confiuration.title_text, //false deaktiviert!
                colorTitle: confiuration.title_fontColor,
                fontTitleSize: confiuration.title_fontSize,

                //plate
                colorPlate: confiuration.plate_colorPlate,
                colorPlateEnd: confiuration.plate_colorPlateEnd,
                borderShadowWidth: 0,
                borderOuterWidth: 0,
                borders: false,

                //needle
                needle: confiuration.needle_display,//show needle
                needvarype: confiuration.needle_Type, // arrow
                needleStart: confiuration.needle_start, //in %
                needleEnd: confiuration.needle_end,//in %
                needleWidth: confiuration.needle_width, //in Px
                colorNeedle: confiuration.needle_colorNeedle,
                colorNeedleEnd: confiuration.needle_colorNeedleEnd,
                needleSide: confiuration.linear_needleSide, //“right”, “both” => nur bei linear

                //valuebox
                valueBox: confiuration.valuebox_display,
                colorValueBoxBackground: confiuration.valuebox_colorValueBoxBackground,
                colorValueBoxShadow: false,//'rgba(255, 0, 122, 0)'

                valueBoxBorderRadius: 0,
                valueTextShadow: false,
                valueBoxStroke: 0,
                valueBoxWidth: 10,

                //progressbar
                colorBar: confiuration.progressbar_colorBar,
                colorBarProgress: confiuration.progressbar_colorBarProgress,
                barShadow: confiuration.progressbar_barShadow,
                barWidth: confiuration.progressbar_barWidth,
                barBeginCircle: false,
                //barStartPosition: 'right',

                //Ticks
                tickSide: confiuration.linear_tickSide, //“right”, “both”. => nur bei linear
                numberSide: confiuration.linear_numberSide, //“right”, “both”. => nur bei linear
                startAngle: confiuration.radial_startAngle, //=> nur bei Radial
                ticksAngle: confiuration.radial_ticksAngle,//=> nur bei Radial
                colorMajorTicks: confiuration.ticks_colorMajorTick,
                colorMinorTicks: confiuration.ticks_colorMinorTicks,
                colorUnits: confiuration.ticks_colorUnits,
                colorNumbers: confiuration.ticks_colorNumbers,
                minorTicks: confiuration.ticks_minorTicks,
                strokeTicks: confiuration.ticks_strokeTicks,
                highlightsWidth: confiuration.ticks_highlightsWidth,
                highlights: config_highlights,
                majorTicks: config_ticks,
                fontNumbersSize: confiuration.ticks_fontSize,

                needleCircleSize: 50,
                needleCircleOuter: 10,
                colorNeedleCircleOuter: 'rgba(0,0,0,0)',
                colorNeedleShadowDown: 'rgba(0,0,0,0)',
                needleCircleOuter: true,
                needleCircleInner: false,
                colorNeedleShadowDown: 'rgba(0,0,0,0)',
                colorNeedleCircleOuter: 'rgba(0,0,0,0)',
                colorNeedleCircleOuterEnd: 'rgba(0,0,0,0)',
                colorNeedleCircleInner: 'rgba(255,255,255,1)',
                colorNeedleCircleInnerEnd: 'rgba(255,255,255,1)',


                animationRule: confiuration.animation_rule, //'linear', //”, “quad”, “quint”, “cycle”, “bounce”, “elastic”  “dequad”, “dequint”, “decycle”, “debounce”, “delastic”.
                animationDuration: confiuration.animation_duration
            }

            if(confiuration.title_fontFamily !== ""){
                gauge_config.fontTitle = confiuration.title_fontFamily;
            }

            if(confiuration.ticks_fontFamily !== ""){
                gauge_config.fontNumbers = confiuration.ticks_fontFamily;
            }

            if(confiuration.valuebox_fontFamily !== ""){
                gauge_config.fontValue = confiuration.valuebox_fontFamily;
            }

            gauge = new RadialGauge(gauge_config);
            gauge.draw();
        }catch (e){
            alert(e);
        }
    }

    function connect() {
        var ws = new WebSocket(location['protocol'].replace(/^http/, 'ws') + "//" + location['host'] + "/hook/JSLive/WS/" + {INSTANCE});
        ws.onopen = function() {
            // subscribe to some channels
            //ws.send(JSON.stringify({
            //.... some message the I must send when I connect ....
            //}));
        };

        ws.onmessage = function(e) {
            data = JSON.parse(e.data);
            if(data.Message == 10506) {
                //refresh webseite
                location.reload();
            } else if(data.Message == 10603) {
                UpdateGauge(data.SenderID, data.Data[0]);
            }
        };

        ws.onclose = function(e) {
            console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
            setTimeout(function() {
                connect();
            }, 1000);
        };

        ws.onerror = function(err) {
            console.error('Socket encountered error: ', err.message, 'Closing socket');
            ws.close();
        };
    }

    function UpdateGauge(id_val, val){
        isUpdated = false;

        if(id_val == confiuration.Variable){
            //console.log(val);
            gauge.value = val;
        }
    }

    async function PullNewData(refreshRate){
        refreshRate = refreshRate * 1000;
        while (true){
            try {
                $.getJSON("/hook/JSLive/getData?Instance={INSTANCE}&pw={PASSWORD}", function (data) {
                    data.forEach(function (part, index) {
                        UpdateGauge(part.Variable, part.Value);
                    });
                });

                //Control Variables
            }catch (e) {
                console.log("PullNewData => ", e);
            }
            await sleep(refreshRate);
        }
    }



    window.onload = function() {
        try {
            LoadGauge();
            if (config_global.LocalAddress == "" && config_global.LocalDataMode == 0) {
                //pullup Mode local
                refreshRate = config_global.LocalRefreshTime;
                PullNewData(refreshRate);
            } else if (config_global.RemoteAddress == "" && config_global.RemoteDataMode == 0) {
                //pullup Mode remote
                refreshRate = config_global.RefreshTime;
                PullNewData(refreshRate);
            } else {
                connect();
            }
        }catch (e) {
            alert("Gauge Radial | ",e);
        }
    }

    document.fonts.ready.then(function () {
        gauge.update();
    });

</script>
</body>
</html>